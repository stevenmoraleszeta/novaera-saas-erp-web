// Servicio para opciones personalizadas de columnas
const pool = require('../config/db');

// Crear la tabla column_options si no existe
const ensureTableExists = async (client) => {
  const tableExists = await client.query(`
    SELECT EXISTS (
      SELECT FROM information_schema.tables 
      WHERE table_schema = 'public' 
      AND table_name = 'column_options'
    );
  `);
  
  if (!tableExists.rows[0].exists) {
    await client.query(`
      CREATE TABLE "column_options" (
        "id" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        "column_id" INT NOT NULL,
        "option_value" VARCHAR(255) NOT NULL,
        "option_label" VARCHAR(255) NOT NULL,
        "option_order" INT DEFAULT 0,
        "is_active" BOOLEAN DEFAULT true,
        "created_at" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        CONSTRAINT fk_column_options_column FOREIGN KEY ("column_id") REFERENCES "columns" ("id") ON DELETE CASCADE
      );
    `);
    
    // Crear índices
    await client.query(`
      CREATE INDEX IF NOT EXISTS idx_column_options_column_id ON "column_options" ("column_id");
      CREATE INDEX IF NOT EXISTS idx_column_options_is_active ON "column_options" ("is_active");
      CREATE INDEX IF NOT EXISTS idx_column_options_order ON "column_options" ("column_id", "option_order");
    `);
  }
};

// Crear/actualizar opciones personalizadas para una columna
exports.createColumnOptions = async (column_id, options) => {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    // Asegurar que la tabla existe
    await ensureTableExists(client);
    
    // Eliminar opciones existentes de esta columna antes de insertar nuevas
    await client.query('DELETE FROM column_options WHERE column_id = $1', [column_id]);
    
    // Insertar nuevas opciones
    if (options && options.length > 0) {
      for (let i = 0; i < options.length; i++) {
        const option = options[i];
        // Si es string simple, usar como valor y etiqueta
        const optionValue = typeof option === 'string' ? option : option.value;
        const optionLabel = typeof option === 'string' ? option : option.label;
        
        await client.query(
          'INSERT INTO column_options (column_id, option_value, option_label, option_order) VALUES ($1, $2, $3, $4)',
          [column_id, optionValue, optionLabel, i]
        );
      }
    }
    
    await client.query('COMMIT');
    return true;
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
};

// Obtener opciones de una columna
exports.getColumnOptions = async (column_id) => {
  const client = await pool.connect();
  try {
    // Asegurar que la tabla existe
    await ensureTableExists(client);
    
    const result = await client.query(
      'SELECT * FROM column_options WHERE column_id = $1 AND is_active = true ORDER BY option_order',
      [column_id]
    );
    return result.rows;
  } catch (error) {
    // Si la tabla no existe, retornar array vacío
    if (error.code === '42P01') { // PostgreSQL error code for "relation does not exist"
      return [];
    }
    throw error;
  } finally {
    client.release();
  }
};

// Actualizar una opción específica
exports.updateColumnOption = async (option_id, option_data) => {
  try {
    // Construir dinámicamente el query y los valores
    const fields = [];
    const values = [];
    let idx = 1;
    if (option_data.option_value !== undefined) {
      fields.push(`option_value = $${idx++}`);
      values.push(option_data.option_value);
    }
    if (option_data.option_label !== undefined) {
      fields.push(`option_label = $${idx++}`);
      values.push(option_data.option_label);
    }
    if (option_data.option_order !== undefined) {
      fields.push(`option_order = $${idx++}`);
      values.push(option_data.option_order);
    }
    if (option_data.is_active !== undefined) {
      fields.push(`is_active = $${idx++}`);
      values.push(option_data.is_active);
    }
    if (fields.length === 0) {
      throw new Error('No hay campos para actualizar');
    }
    values.push(option_id);
    const query = `UPDATE column_options SET ${fields.join(', ')} WHERE id = $${idx} RETURNING *`;
    const result = await pool.query(query, values);
    return result.rows[0];
  } catch (error) {
    if (error.code === '42P01') {
      return null; // Tabla no existe, retornar null
    }
    throw error;
  }
};

// Eliminar una opción específica (soft delete)
exports.deleteColumnOption = async (option_id) => {
  try {
    const result = await pool.query(
      'UPDATE column_options SET is_active = false WHERE id = $1 RETURNING *',
      [option_id]
    );
    return result.rows[0];
  } catch (error) {
    if (error.code === '42P01') {
      return null; // Tabla no existe, retornar null
    }
    throw error;
  }
};

// Eliminar todas las opciones de una columna
exports.deleteColumnOptions = async (column_id) => {
  try {
    await pool.query('DELETE FROM column_options WHERE column_id = $1', [column_id]);
    return true;
  } catch (error) {
    if (error.code === '42P01') {
      return true; // Tabla no existe, retornar éxito
    }
    throw error;
  }
};

// Verificar si una columna existe
exports.columnExists = async (column_id) => {
  const result = await pool.query(
    'SELECT 1 FROM columns WHERE id = $1',
    [column_id]
  );
  return result.rows.length > 0;
};

// Obtener opciones disponibles para una columna (personalizadas o de tabla foránea)
exports.getAvailableOptions = async (column_id) => {
  // Primero obtener información de la columna
  const columnResult = await pool.query(
    'SELECT * FROM columns WHERE id = $1',
    [column_id]
  );
  
  if (columnResult.rows.length === 0) {
    throw new Error('Columna no encontrada');
  }
  
  const column = columnResult.rows[0];
  
  // Si la columna no es de tipo selección, retornar array vacío
  if (column.data_type !== 'select') {
    return [];
  }
  
  
  // Si es una columna de foreign key, obtener opciones de la tabla referenciada
  if (column.foreign_table_id && column.foreign_column_name) {
    const tableResult = await pool.query(
      'SELECT id, record_data FROM records WHERE table_id = $1 AND record_data ? $2 ORDER BY id',
      [column.foreign_table_id, column.foreign_column_name]
    );
    
    const options = tableResult.rows
      .filter(record => {
        const fieldValue = record.record_data[column.foreign_column_name];
        return fieldValue && fieldValue !== '';
      })
      .map(record => ({
        value: record.id,
        label: record.record_data[column.foreign_column_name],
        type: 'foreign'
      }));
      
    return options;
  }
  
  // Si no es foreign key, verificar si tiene opciones personalizadas
  const customOptions = await this.getColumnOptions(column_id);
  
  // Si tiene opciones personalizadas, retornarlas
  if (customOptions.length > 0) {
    return customOptions.map(option => ({
      value: option.option_value,
      label: option.option_label,
      type: 'custom'
    }));
  }
  
  return [];
};
